name: Docker Image CI

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:
#  pull_request:
#    branches: [ "master" ]

jobs:
#  build:
#    runs-on: ubuntu-latest
#    steps:
#    - uses: actions/checkout@v3
#      with:
#        fetch-depth: 0
#    - name: Build the Docker image
#      run: docker compose build
#    - name: Run container
#      run: |
#        docker compose up -d
#    - name: Check loading services
#      run: |
#        chmod +x ./scripts/wait-script.sh
#        chmod +x ./scripts/wait-for.sh
#        chmod +x ./scripts/test-script.sh
#        ./scripts/wait-script.sh
#      env:
#        WAIT_PORTS: 8080,8070,8060,8050
#    - name: Check service dropout on 8050 port
#      run: |
#        ./scripts/test-script.sh
#      env:
#        VARIANT: v2
#        SERVICE_NAME: loyalty_service
#        PORT_NUMBER: 8050
#
#  publish:
#    runs-on: ubuntu-latest
#    needs: [ build ]
#    steps:
#    - uses: actions/checkout@v3
#    - name: Pull docker image to docker registry
#      env:
#        registry_token: ${{ secrets.REGISTRY_PULL_TOKEN }}
#      run: |
#        echo $registry_token | docker login ghcr.io -u laserkillers --password-stdin
#
#        cd ./webapp
#
#        docker build -f DockerFileGatewayRun -t ghcr.io/laserkillers/rsoi_labs/lab_2_service_gateway:latest .
#        docker push ghcr.io/laserkillers/rsoi_labs/lab_2_service_gateway:latest
#
#        docker build -f DockerFileReserveServiceRun -t ghcr.io/laserkillers/rsoi_labs/lab_2_service_reserve:latest .
#        docker push ghcr.io/laserkillers/rsoi_labs/lab_2_service_reserve:latest
#
#        docker build -f DockerFilePaymentServiceRun -t ghcr.io/laserkillers/rsoi_labs/lab_2_payment_service:latest .
#        docker push ghcr.io/laserkillers/rsoi_labs/lab_2_payment_service:latest
#
#        docker build -f DockerFileLoyaltyServiceRun -t ghcr.io/laserkillers/rsoi_labs/lab_2_loyalty_service:latest .
#        docker push ghcr.io/laserkillers/rsoi_labs/lab_2_loyalty_service:latest

  deploy-to-kuber:
    runs-on: ubuntu-latest
#    needs: [ publish ]
    steps:
      - uses: actions/checkout@v3
      - name: Release to kubernetes
        env:
          OS_PASSWORD: ${{ secrets.OS_PASSWORD }}
        run: |
          curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x ./kubectl
          export KUBECONFIG="$(pwd)/kuber_templates/kubeconfig.yaml"
          echo OS_PASSWORD | ./kubectl cluster-info
          ./kubectl cluster-info
          ./kubectl cluster-info dump

#        ./kubectl create secret docker-registry myprivateregistry --docker-server=$REGISTRY_URL --docker-username=$DOCKER_USER --docker-password=$DOCKER_PASSWORD --dry-run -o yaml | ./kubectl apply -f -
#        ./kubectl apply -f manifests/deployment.yaml
#        ./kubectl apply -f manifests/service.yaml
#        ./kubectl apply -f manifests/ingress.yaml
#        ./kubectl rollout restart deployment

#      - uses: actions/checkout@v3
#      - name: Setup kubeconfig
#        run: echo "${{ secrets.KUBECONFIG }}" > kubeconfig.yaml
#
#      - name: Deploy to Kubernetes
#        uses: appleboy/deploy-k8s@v1
#        with:
#          kubeconfig: kubeconfig.yaml
#          manifest: kubernetes/*.yaml

#      - name: 'Deploy'
#        run: |
#
#          kubectl cluster-info
#          kubectl cluster-info dump
#
#          kubectl delete -f ./kuber_templates/hotel.yml
#          kubectl delete -f ./kuber_templates/hotel-ingress.yml
#
#          kubectl apply -f ./kuber_templates/hotel.yml
#          kubectl apply -f ./kuber_templates/hotel-ingress.yml
#        env:
#          KUBECONFIG_FILE: '${{ secrets.KUBECONFIG }}'


#    - name: Check service dropout on 8070 port
#      run: |
#        ./scripts/test-script.sh
#      env:
#        VARIANT: v2
#        SERVICE_NAME: reserve_service
#        PORT_NUMBER: 8070
#
#    - name: Check service dropout on 8060 port
#      run: |
#        ./scripts/test-script.sh
#      env:
#        VARIANT: v2
#        SERVICE_NAME: payment_service
#        PORT_NUMBER: 8060

#    - name: Check service dropout on 8050 port
#      run: |
#        ./scripts/test-script.sh
#      env:
#        VARIANT: v2
#        SERVICE_NAME: loyalty_service
#        PORT_NUMBER: 8050
#
#  test:
#    runs-on: ubuntu-latest
#    needs: [ build ]
#    steps:
#    - uses: actions/checkout@v3
#    - name: Build and run tests the Docker image
#      run: docker-compose -f test_docker-compose.yml up --build --abort-on-container-exit --exit-code-from flask_web
#
#  deploy-gateway:
#    runs-on: ubuntu-latest
#    needs: [ test ]
#    steps:
#    - uses: actions/checkout@v3
#    - name: Trigger deploy via Render API
#      env:
#        deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL_GATEWAY }}
#      run:
#          curl "$deploy_url"
#    - name: Wait for deploy
#      run: sleep 5m
#
#  deploy-reservation-service:
#    runs-on: ubuntu-latest
#    needs: [ test ]
#    steps:
#      - uses: actions/checkout@v3
#      - name: Trigger deploy via Render API
#        env:
#          deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL_RESERVE }}
#        run:
#          curl "$deploy_url"
#      - name: Wait for deploy
#        run: sleep 5m
#
#  deploy-loyalty-service:
#    runs-on: ubuntu-latest
#    needs: [ test ]
#    steps:
#      - uses: actions/checkout@v3
#      - name: Trigger deploy via Render API
#        env:
#          deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL_LOYALTY }}
#        run:
#          curl "$deploy_url"
#      - name: Wait for deploy
#        run: sleep 5m
#
#  deploy-payment-service:
#    runs-on: ubuntu-latest
#    needs: [ test ]
#    steps:
#      - uses: actions/checkout@v3
#      - name: Trigger deploy via Render API
#        env:
#          deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL_PAYMENT }}
#        run:
#          curl "$deploy_url"
#      - name: Wait for deploy
#        run: sleep 5m
#
#  run_api_tests:
#    runs-on: ubuntu-latest
#    needs: [ deploy-gateway, deploy-reservation-service, deploy-loyalty-service, deploy-payment-service]
#    steps:
#      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
#      - uses: actions/checkout@v3
#
#      # INstall Node on the runner
#      - name: Install Node
#        uses: actions/setup-node@v3
#        with:
#          node-version: '16.x'
#
#      # Install the newman command line utility and also install the html extra reporter
#      - name: Install newman
#        run: npm install -g newman
#
#      # Install the html extra reporter
##      - name: Install reporter
##        run: npm install -g newman-reporter-htmlextra
#
#      # Make directory to upload the test results
#      - name: Make Directory for results
#        run: mkdir -p testResults
#
#      # Run the POSTMAN collection
#      - name: Run POSTMAN collection
#        run: |
#          newman run ./postman/postman_collection.json -e ./postman/postman_environment.json
#
#      # Upload the contents of Test Results directory to workspace
#      - name: Output the run Details
#        uses: actions/upload-artifact@v2
#        with:
#          name: RunReports
#          path: testResults
